/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#include "bundle_types.h"
#include <thrift.h>

/* constants */

/* reads a metric object */
gint32
metric_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Metric * this_object = METRIC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->metricType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_metricType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->valueDbl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valueDbl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->valueI64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valueI64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->valueI32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valueI32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->valueStr, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valueStr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
metric_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Metric * this_object = METRIC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Metric", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "metricType", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->metricType, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_valueDbl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "valueDbl", T_DOUBLE, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->valueDbl, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_valueI64 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "valueI64", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->valueI64, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_valueI32 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "valueI32", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->valueI32, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_valueStr == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "valueStr", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->valueStr, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
metric_instance_init (Metric * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->metricType = 0;
  object->__isset_metricType = FALSE;
  object->valueDbl = 0;
  object->__isset_valueDbl = FALSE;
  object->valueI64 = 0;
  object->__isset_valueI64 = FALSE;
  object->valueI32 = 0;
  object->__isset_valueI32 = FALSE;
  object->valueStr = NULL;
  object->__isset_valueStr = FALSE;
}

void 
metric_finalize (GObject *object)
{
  Metric *tobject = METRIC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
metric_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = metric_finalize;
  cls->read = metric_read;
  cls->write = metric_write;
}

GType
metric_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MetricClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) metric_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Metric),
      0, /* n_preallocs */
      (GInstanceInitFunc) metric_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MetricType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bundle object */
gint32
bundle_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Bundle * this_object = BUNDLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->available, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_available = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->state, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_state = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->duration, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_duration = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->status, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key0;
              Metric * val1;
              if ((ret = thrift_protocol_read_string (protocol, &key0, error)) < 0)
                return -1;
              xfer += ret;
              val1 = g_object_new (TYPE_METRIC, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val1), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->metrics, (gpointer) &key0, (gpointer) &val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_metrics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
bundle_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Bundle * this_object = BUNDLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bundle", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "available", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->available, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "state", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->state, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "duration", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->duration, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->status, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_metrics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "metrics", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, (gint32) g_hash_table_size ((GHashTable *) this_object->metrics), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      Metric * value;
      g_hash_table_foreach ((GHashTable *) this_object->metrics, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (Metric *) g_hash_table_lookup (((GHashTable *) this_object->metrics), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return -1;
        if ((ret = thrift_struct_write (THRIFT_STRUCT ( value), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
bundle_instance_init (Bundle * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->available = 0;
  object->__isset_available = FALSE;
  object->state = 0;
  object->__isset_state = FALSE;
  object->duration = 0;
  object->__isset_duration = FALSE;
  object->status = NULL;
  object->__isset_status = FALSE;
  object->metrics = g_hash_table_new (NULL, NULL);
  object->__isset_metrics = FALSE;
}

void 
bundle_finalize (GObject *object)
{
  Bundle *tobject = BUNDLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_hash_table_unref (tobject->metrics);
}

void 
bundle_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = bundle_finalize;
  cls->read = bundle_read;
  cls->write = bundle_write;
}

GType
bundle_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BundleClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bundle_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Bundle),
      0, /* n_preallocs */
      (GInstanceInitFunc) bundle_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BundleType",
                                   &type_info, 0);
  }

  return type;
}

